<!--
    options: toc
    to: html-N
-->

% map -- making xargs simpler *and* more powerful!

`map` can replace xargs for most purposes as well as replace many `for` loops
in shell.  Clone the [repo](https://github.com/sitaramc/map) or grab just the
[script](https://raw.githubusercontent.com/sitaramc/map/master/map).  Run `map
-h` to get some quick help, but be aware that only scratches the surface!

Compared to xargs, map has very few options, and a fixed set of "replace
strings", all using the `%` character.  This document describes the `map`
command, with xargs comparisons when needed.

@@gray(In addition, there's something called [GNU Parallel][gp] with a
**huge** list of examples on its pages.  Casually looking at the examples, I
found that `map` could do pretty much all of the generic ones!  So I wrote up
a [feature comparison][mapgp], (including things that map
[can't/won't][mapgpcw] do).  As you read that page, remember that map is 330
lines of perl, and GNU Parallel is 5000 lines.  Also remember that map has 3
options (if you don't count -h, -q, and -v), GNU Parallel has almost a 100!)@@

[gp]: http://www.gnu.org/software/parallel/
[mapgp]: map-vs-gp.html
[mapgpcw]: map-vs-gp.html#cantwont

# map compared to xargs

Note that a good way to play with these examples is to use `seq 1 5` as input,
and just `echo` as the command.  Keep that in mind as you go through these
examples.

## line-oriented, not word oriented

Map will treat each input line as one single argument; it will not
space-separate them like xargs does.  (But please see the IMPORTANT NOTES
section later for some edge cases).  So:

    find ..blah-blah.. -print0  | xargs -0 some.command

becomes

    find ..blah-blah..          | map some.command

## simpler "replace" strings

Map's **replace strings** are `%` and `%%`.  A single % means substitute
exactly one input item and run the command, while a double % means to
substitute as many input items as possible (subject to '-n' and total command
length) before running the command (like xargs).

@@gray(Map also has a pretty cool "delimiter mode" that at first seems totally
unrelated to xargs but actually is not.  See later for examples.)@@

## argument in the middle

`xargs` is painful for commands where the argument should be in the middle,
like say a copy command.  Map is much simpler:

    find ..blah-blah.. | map cp % destination       # one file per command

With xargs, even when you get the syntax right, you can only run the command
for one argument at a time, which is often inefficient.  With map, just use %%
instead of %:

    find ..blah-blah.. | map cp %% destination      # several files per command

# beyond xargs...

## four types of placeholders, not just one

You've seen % and %%.  But there are also %D (directory part), %B (basename of
the file) and %E (extension).  You can do things like:

    # convert markdown files to html and put them in the "html/" directory
    map "pandoc % -i html/%B.html" *.mkd

Here's another example.  Print the name of every directory that contains
photographs from my camera. (My camera produces files that look like
`IMG_1234.JPG`, although sometimes I make them lowercase)

    find . -type f -iname "img*.jpg" | map echo %D | sort -u

## not just for STDIN (a.k.a., replacing 'for' loops in shell)

Map will happily treat the first argument as the command and the rest as input
"lines" if STDIN is not a pipe.  This lets you do things like this:

    map gzip *.pdf
    # same as:      ls *.pdf | map gzip
    # or:           ls *.pdf | xargs -I {} gzip {}
    # or:           for i in *.pdf; do gzip $i; done

Want options for the command?  Quote the entire first argument:

    # produce separate zip files for each directory
    map "zip -q -r % %" src doc conf contrib hooks
    # same as:      for i in src doc conf contrib hooks
    #               do
    #                   zip -q -r $i $i
    #               done

## placeholders and words

When replacing %%, map looks at the entire *word* (space delimited), and
inserts that.  Here's an example:

    seq 1 3 | map echo abc.%.def
    # or:   map "echo abc.%.def" 1 2 3
    # prints:
    #       abc.1.def
    #       abc.2.def
    #       abc.3.def

Both xargs and for loops can do that.  What neither of them can do is this:

    seq 1 3 | map echo abc.%%.def
    # or:   map "echo abc.%%.def" 1 2 3
    # prints:
    #       abc.1.def abc.2.def abc.3.def

# details

## default replacement string {#drs}

If no replacement string (%, %%, or variants) exist anywhere in the command,
the default is to assume a '%%' at the end.

However, if the '-p' option is used *without* the '-n' option, the default
becomes '%'.

## single replacements

`%` is replaced by the current input line, with a trailing slash removed if
present.  `%D` is replaced by the directory name of the current filename.
`%B` is the basename and `%E` is the extension.  (This means that `%` is
pretty much equal to `%D/%B.%E`).

As said above, these replacements use only one input line per run, so

    seq 1 3 | map echo %

gives you

    1
    2
    3

## multiple replacements

Most often, you want all the arguments tacked on to one "run" of the
the command.  Do this by specifying a `%%`:

    seq 1 3 | map echo %%
    # returns:
    1 2 3

Since this is the most common reason for using map, this is the default if you
don't specify either % or %%:

    seq 1 3 | map echo
    # same as above

A `%%` (and similarly `%%D`, `%%B`, and `%%E`) get replaced by as many input
lines as possible (subject to internal limit of command line length and the
user-specified `-n` value if used).

This replacement even works within a word, replicating the entire word:

    seq 1 3 | map echo abc-%%-def

produces

    abc-1-def abc-2-def abc-3-def

## multiple jobs in parallel

When you run something like:

    map -p 4 gzip *.pdf

you are running 4 jobs in parallel.  This indicates that the job might be CPU
bound (usually, though not always) so it's best to run each job on one input
line rather than give it as many as it will take.

So when you run in parallel mode, the default is `%` because that is what
makes sense.

As a convenience, when you say '-p 0', map sets it to the number of CPUs on
the system plus two.

## specifying maximum arguments per invocation

However, if you use `-n`, (even if you are also using `-p`) the default
switches back to `%%`.  The logic is that specifying "maximum arguments per
invocation" implicitly gives permission to actually *have* more than one
argument, overriding the `-p` exception.

So yeah this is an exception to an exception but I don't think it's too hard
to remember.  And if in doubt you can always specify what you want anyway.

## delimiter mode

Here's an example; more documentation may follow if anyone asks but notice the
delimiter character (colon) and the specification of field 1 and field 7:

    cat /etc/passwd | egrep -v 'nologin|bash' | map -d=: echo %1 use %7 as shell

The default delimiter is whitespace (but you have to use '-d=', not just
'-d').  For convenience, '-d=t' uses tabs.  Anything else, like ':', is
specified literally, like above.

Here's another example: report users who have some shell as login but no GECOS
field:

     < /etc/passwd map -d=: -- '[[ %7 =~ sh ]] && [ -z "%5" ] && echo %1 || :'

# IMPORTANT NOTES {#IN}

## Filenames with unusual characters

Map **will** work fine with such filenames **except that** you have to do some
extra quoting for parallel mode (since that invokes xargs), or if you want to
use redirection or multiple commands.

For example (assuming some command sending in a list of filenames), this will
fail:

    ... | map 'echo -n `gzip <  %  | wc -c`; echo -n '*100/'; wc -c <  % ' | bc

but this will succeed:

    ... | map 'echo -n `gzip < "%" | wc -c`; echo -n '*100/'; wc -c < "%"' | bc

(by the way, this computes the size of the gzipped file as a percentage of the
original)

## OTHER WARNINGS

  * never mix the 3 styles of replacement strings ('%' and its cousins, '%%'
    and its cousins, and '%1', '%2', etc for delimiter mode).  Odd things will
    happen -- I don't check for sanity.
